.. raw:: html

    <code class="vert-shader common-shader">
        attribute vec4 a_vec4_combined;
        varying vec2 v_vec2_texCoords;
        void main() {
            v_vec2_texCoords = a_vec4_combined.zw;
            gl_Position = vec4(a_vec4_combined.xy, 0, 1);
        }
    </code>
    <code class="frag-shader common-shader">
        #extension GL_OES_standard_derivatives : enable
        precision mediump float;
        uniform vec2 u_vec2_mouse;
        varying vec2 v_vec2_texCoords;
        vec4 original_image(vec2 texCoords) {
            return vec4(vec3(
                mod(floor(texCoords.x*10.0)+floor(texCoords.y*10.0), 2.0)
            ), 1);
        }


    </code>

The distortion vector field is computed from the gradient of a scalar "potential" field. This can be an image texture or a procedure. This effect only moves, scales and shears (small) patches of an image. It can't rotate any patches of the image in-place or with translation; Swirl-like effects are impossible to achieve with this technique alone.

.. raw:: html

         <div class="gl-ide gl-distortion-demo-1">
         <h3>Original Image</h3>
         <canvas class="gl-canvas"></canvas>
         <div class=".gl-editor"><pre><code class="language-glsl">#extension GL_OES_standard_derivatives : enable
         precision mediump float;
         uniform vec2 u_vec2_mouse;
         varying vec2 v_vec2_texCoords;
         vec4 original_image(vec2 texCoords) {
             return vec4(vec3(
                 mod(floor(texCoords.x*10.0)+floor(texCoords.y*10.0), 2.0)
             ), 1);
         }</code></pre></div>
         </div>
         <div class="gl-ide gl-distortion-demo-2">
         <h3>Distortion Potential</h3>
         <canvas class="gl-canvas"></canvas>
         <div class=".gl-editor"><pre><code class="language-glsl">#extension GL_OES_standard_derivatives : enable
         precision mediump float;
         uniform vec2 u_vec2_mouse;
         varying vec2 v_vec2_texCoords;
         vec4 original_image(vec2 texCoords) {
             return vec4(vec3(
                 mod(floor(texCoords.x*10.0)+floor(texCoords.y*10.0), 2.0)
             ), 1);
         }</code></pre></div>
         </div>
         <div class="gl-ide gl-distortion-demo-3">
         <h3>Distorted Image</h3>
         <canvas class="gl-canvas"></canvas>
         <div class=".gl-editor"><pre><code class="language-glsl">#extension GL_OES_standard_derivatives : enable
         precision mediump float;
         uniform vec2 u_vec2_mouse;
         varying vec2 v_vec2_texCoords;
         vec4 original_image(vec2 texCoords) {
             return vec4(vec3(
                 mod(floor(texCoords.x*10.0)+floor(texCoords.y*10.0), 2.0)
             ), 1);
         }</code></pre></div>
         </div>


You have two options for computing the distortion from the distortion potential. You can call dFdx and dFdy and get the gpu's best guess of the gradient, or you can analytically solve for the gradient ahead of time.
This effect is also a useful approximation of caustics in the paraxial limit (looking along the normal to a the surface). Here are some examples of the distortion caused by the wavy surface of a swimming pool using the same code as the before.

.. raw:: html
         figure and code

         The image as seen overhead above the surface.

.. raw:: html
         figure and code

         Refracted light from a sun overhead as seen below the surface.

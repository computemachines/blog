.. raw:: html

    <code class="vert-shader common-shader">
        attribute vec4 a_vec4_combined;
        varying vec2 v_vec2_texCoords;
        void main() {
            v_vec2_texCoords = a_vec4_combined.zw;
            gl_Position = vec4(a_vec4_combined.xy, 0, 1);
        }
    </code>
    <code class="frag-shader common-shader">
        #extension GL_OES_standard_derivatives : enable
        precision mediump float;
        uniform vec2 u_vec2_mouse;
        varying vec2 v_vec2_texCoords;
        vec4 original_image(vec2 texCoords) {
            return vec4(vec3(
                mod(floor(texCoords.x*10.0)+floor(texCoords.y*10.0), 2.0)
            ), 1);
        }
        float sq(float x) { reutrn
        float distortion_potential(vec2 texCoords){
            return exp(

    </code>

The distortion vector field is computed from the gradient of a scalar "potential" field. This can be an image texture or a procedure. This effect only moves, scales and shears (small) patches of an image. It can't rotate any patches of the image in-place or with translation; Swirl-like effects are impossible to achieve with this technique alone.

.. raw:: html

         <div class="gl-ide gl-distortion-demo-1">
         <h3>Original Image</h3>
         <canvas class="gl-canvas"></canvas>
         <div class=".gl-editor"><pre><code class="language-glsl">#extension GL_OES_standard_derivatives : enable
         precision mediump float;
         uniform vec2 u_vec2_mouse;
         varying vec2 v_vec2_texCoords;
         vec4 original_image(vec2 texCoords) {
             return vec4(vec3(
                 mod(floor(texCoords.x*10.0)+floor(texCoords.y*10.0), 2.0)
             ), 1);
         }</code></pre></div>
         </div>
         <div class="gl-ide gl-distortion-demo-2">
         <h3>Distortion Potential</h3>
         <canvas class="gl-canvas"></canvas>
         <div class=".gl-editor"><pre><code class="language-glsl">#extension GL_OES_standard_derivatives : enable
         precision mediump float;
         uniform vec2 u_vec2_mouse;
         varying vec2 v_vec2_texCoords;
         vec4 original_image(vec2 texCoords) {
             return vec4(vec3(
                 mod(floor(texCoords.x*10.0)+floor(texCoords.y*10.0), 2.0)
             ), 1);
         }</code></pre></div>
         </div>
         <div class="gl-ide gl-distortion-demo-3">
         <h3>Distorted Image</h3>
         <canvas class="gl-canvas"></canvas>
         <div class=".gl-editor"><pre><code class="language-glsl">#extension GL_OES_standard_derivatives : enable
         precision mediump float;
         uniform vec2 u_vec2_mouse;
         varying vec2 v_vec2_texCoords;
         vec4 original_image(vec2 texCoords) {
             return vec4(vec3(
                 mod(floor(texCoords.x*10.0)+floor(texCoords.y*10.0), 2.0)
             ), 1);
         }</code></pre></div>
         </div>


You have two options for computing the distortion from the distortion potential. You can call dFdx and dFdy and get the gpu's best guess of the gradient, or you can analytically solve for the gradient ahead of time.

.. raw:: math
         distortedImage(x, y) = image(x+\frac{\partial F}{\partial x}, y+\frac{\partial F}{\partial y}))

